using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;

namespace Asteroid_Belt_Assault //pg 104 
{
    class AsteroidManager
    {
        private int screenWidth = 800;
        private int screenHeight = 600;
        private int screenPadding = 10;

        private Rectangle initialFrame;
        private int asteroidFrames;
        private Texture2D texture;

        public List<Sprite> Asteroids = new List<Sprite>(); //list where asteroids will be stored
        private int minSpeed = 60;
        private int maxSpeed = 120;

        private Random rand = new Random();

        public void AddAsteroid()//helper method to be used by AsteroidManager constructor
        {
            Sprite newAsteroid = new Sprite(
                new Vector2(-500, -500), //when generated, asteroid begins at -500, -500 and repositioned during the update method
                texture,
                initialFrame,
                Vector2.Zero);
            for (int x = 1; x < asteroidFrames; x++) //shifts between the frames of animation
            {
                newAsteroid.AddFrame(new Rectangle(
                    initialFrame.X + (initialFrame.Width * x),
                    initialFrame.Y,
                    initialFrame.Width,
                    initialFrame.Height));
            }

            newAsteroid.Rotation =
                MathHelper.ToRadians((float)rand.Next(0, 360));
            newAsteroid.CollisionRadius = 15;
            Asteroids.Add(newAsteroid);
        }

        public void Clear()
        {
            Asteroids.Clear();
        }//second helper function

        public AsteroidManager(
            int asteroidCount,
            Texture2D texture,
            Rectangle initialFrame,
            int asteroidFrames,
            int screenWidth,
            int screenHeight)
        {
            this.texture = texture;
            this.initialFrame = initialFrame;
            this.asteroidFrames = asteroidFrames;
            this.screenWidth = screenWidth;
            this.screenHeight = screenHeight;
            for (int x = 0; x < asteroidCount; x++)
            {
                AddAsteroid();
            }
        } //end pg 105 code

        private Vector2 randomLocation()//pg 107, adding random locations
        {
            Vector2 location = Vector2.Zero;
            bool locationOK = true;
            int tryCount = 0;

            do //the do while loop checks for any collisions to avoid it
            {
                locationOK = true;
                switch (rand.Next(0, 3))
                {
                    case 0:
                        location.X = -initialFrame.Width;
                        location.Y = rand.Next(0, screenHeight);
                        break;

                    case 1:
                        location.X = screenWidth;
                        location.Y = rand.Next(0, screenHeight);
                        break;

                    case 2:
                        location.X = rand.Next(0, screenWidth);
                        location.Y = -initialFrame.Height;
                        break;
                }
                foreach (Sprite asteroid in Asteroids)
                {
                    if (asteroid.IsBoxColliding( // pg 108 //this checks for collisions
                        new Rectangle(
                            (int)location.X,
                            (int)location.Y,
                            initialFrame.Width,
                            initialFrame.Height)))
                    {
                        locationOK = false; // then sets it to off
                    }
                }
                tryCount++;
                if ((tryCount > 5) && locationOK == false) //if the check fails 5 times, then it's set far off
                {
                    location = new Vector2(-500, -500);
                    locationOK = true;
                }
            } while (locationOK == false);

            return location;
        }

        private Vector2 randomVelocity()
        {
            Vector2 velocity = new Vector2(
                rand.Next(0, 101) - 50,
                rand.Next(0, 101) - 50);
            velocity.Normalize(); //normalizes so that the vector is 1 unit long, but point in random direction
            velocity *= rand.Next(minSpeed, maxSpeed); //then the velocity is multiplied by a random scaling factor
            return velocity;
        }// end pg 108 coding

        private bool isOnScreen(Sprite asteroid) //pg 109, checking for asteroid's position. checks if passed asteroid 
        { //'s destination rectangle intersects a rectangle generated by expanding screenPadding in all directions. 
            if (asteroid.Destination.Intersects(
                new Rectangle(
                    -screenPadding,
                    -screenPadding,
                    screenWidth + screenPadding,
                    screenHeight + screenPadding)
                    )
                )
            {
                return true;
            }
            else
            {
                return false;
            }
        }

        public void Update(GameTime gameTime)//pg 110, updating and drawing asteroids
        {
            foreach (Sprite asteroid in Asteroids)
            {
                asteroid.Update(gameTime);
                if (!isOnScreen(asteroid))
                {
                    asteroid.Location = randomLocation();
                    asteroid.Velocity = randomVelocity();
                }
            }

            for (int x = 0; x < Asteroids.Count; x++) //pg 113, updating the update method
            {
                for (int y = x + 1; y < Asteroids.Count; y++) //checks for collisions with all asteroids
                {//if they do, then they're center to BounceAsteroids
                    if (Asteroids[x].IsCircleColliding(
                        Asteroids[y].Center,
                        Asteroids[y].CollisionRadius))
                    {
                        BounceAsteroids(Asteroids[x], Asteroids[y]);
                    }
                }
            }
        }

        public void Draw(SpriteBatch spriteBatch)
        {
            foreach (Sprite asteroid in Asteroids)
            {
                asteroid.Draw(spriteBatch);
            }
        }

        private void BounceAsteroids(Sprite asteroid1, Sprite asteroid2)// pg 113, bouncing asteroids collision
        {
            {
                Vector2 cOfMass = (asteroid1.Velocity +
                    asteroid2.Velocity) / 2;

                Vector2 normal1 = asteroid2.Center - asteroid1.Center;
                normal1.Normalize(); //normalize causes the vector to have a unit of 1, but in the same direction
                Vector2 normal2 = asteroid1.Center - asteroid2.Center;
                normal2.Normalize(); //vectors are a length property, returns length of hypotenuse 

                asteroid1.Velocity -= cOfMass;
                asteroid1.Velocity =
                    Vector2.Reflect(asteroid1.Velocity, normal1);
                asteroid1.Velocity = asteroid1.Velocity + cOfMass;

                asteroid2.Velocity -= cOfMass;
                asteroid2.Velocity =
                    Vector2.Reflect(asteroid2.Velocity, normal2);

                asteroid2.Velocity += cOfMass;
            }
        }



    }







}
